# xo_game

## วิธีการออกแบบโปรแกรม

1) ออกแบบโมเดลฐานข้อมูล **MySQL**  
มี 2 ตารางหลัก

- **history_xo** (เก็บประวัติการเล่น)
  - `id` : รหัสของประวัติ  
  - `mode` : ประเภทของเกม เช่น `PVP`, `PVBOT`  
  - `sizeBoard` : ขนาดของตารางเกม  
  - `firstPlayer` : ผู้เล่นที่เริ่มก่อน  
  - `winner` : ผู้ชนะ  
  - `botType` : ประเภทของบอท เช่น `random`, `ai`  
  - `finalBoard` : ตารางสุดท้ายตอนจบเกม (บันทึกเป็นข้อความยาว เช่น `O,X,X,O,...`)

- **move** (เก็บการขยับแต่ละตา)
  - `id` : รหัสการขยับ  
  - `historyXO` : อ้างถึง `history_xo` (1 ประวัติ มีได้หลายการขยับ)  
  - `turnNumber` : ลำดับการลง  
  - `player` : ผู้ที่ลง (`"X"` หรือ `"O"`)  
  - `rowIdx` : แถวที่ลง  
  - `colIdx` : คอลัมน์ที่ลง  
  - `boardAfter` : สภาพกระดานหลังตานั้น

2) สร้างโปรเจ็กต์ **Spring Boot**  
**Dependencies** ที่เลือกใช้
- **Spring Web** : ใช้ HTTP/REST ติดต่อกันระหว่าง Frontend กับ Backend  
- **Spring Data JPA** : จัดการข้อมูลกับ DB ได้สะดวก ลดการเขียน SQL ยาว  
- **MySQL Driver** : ใช้ฐานข้อมูล MySQL  
- **Lombok** : ลด code (Getter/Setter/Constructor)

3) สร้างโปรเจ็กต์ **React**
- ใช้ **React Router** จัดการเส้นทางของแต่ละหน้า (Home, Game, Replay)
- ใช้ **Axios** เรียก REST API เชื่อม Frontend ↔ Backend

---

## วิธีการทำงานหลัก (เล่นเกม)

1. หน้า **Home** เมื่อกรอกค่าต่าง ๆ แล้วกดปุ่ม **เริ่มเกม**  
2. ส่งค่าต่าง ๆ `firstPlayer` (สุ่ม), `mode`, `sizeBoard`, `K` (จำนวนเรียงเพื่อชนะ) ไปหน้า **Game**  
3. เมื่อเริ่มหน้า **Game** จะรับค่าจาก Home — ถ้าไม่มีค่า ส่งกลับไปหน้า Home  
4. หน้า Game จะเซ็ตค่าต่าง ๆ  
   - 4.1 นำ `sizeBoard` มาแปลงเป็นตารางว่าง  
   - 4.2 เซ็ตผู้เล่นคนแรกจาก `firstPlayer`  
5. ตั้งตัวแปรเตรียมข้อมูลสำหรับบันทึกลง **DB**  
6. ทุกอย่างเริ่มทำงานเมื่อมีการเดินครั้งแรก (กด `onCellClick` จากตาคนหรือบอท)
   - 6.1 ถ้า `player` คือ `"X"` (คน) → **อัปเดตตาราง**
   - 6.2 ถ้า `player` คือ `"O"` และ `botType = random`
       - 6.2.1 สุ่มช่องว่าง  
       - 6.2.2 **อัปเดตตาราง**
   - 6.3 ถ้า `player` คือ `"O"` และ `botType = ai`
       - 6.3.1 คำนวณ `getBestMove()` เลือกตำแหน่งที่ดีที่สุด  
       - 6.3.2 **อัปเดตตาราง**
   - 6.4 บันทึก DB (ครั้งแรกของเกม)
       - เรียก `ensureHistoryStarted()` → ภายในเรียก `startHistory()`  
         บันทึก `mode`, `sizeBoard`, `firstPlayer`, `botType` และ **รับ `id`** กลับมาเพื่อใช้บันทึกการขยับ
   - 6.5 แปลงตารางเป็นสตริงด้วย `cellsToString()` แล้วเรียก `appendMove()`  
       บันทึก `turnNumber`, `player`, `rowIdx`, `colIdx`, `boardAfter`
   - 6.6 ตรวจผู้ชนะด้วย `checkWinner()`  
       ถ้าชนะ → เรียก `finishHistory()` เพื่อบันทึก `winner`, `finalBoard`
7. กรณีรีเซ็ต/ออกกลางคัน
   - 7.1 ถ้าเกมเริ่มใน DB แล้ว แต่ยังไม่ `finish` ให้ลบด้วย `deleteHistory(id)`

---

## วิธีการทำงานจากหน้า Home → หน้า Replay

1. หน้า **Home** เมื่อกดปุ่ม **Replay** จะส่ง **`id`** ของประวัติไป  
2. หน้า **Replay** รับ `id` จาก URL  
3. เมื่อมาหน้า Replay แล้ว:
   - โหลดข้อมูลประวัติด้วย `getHistory(id)`
   - โหลดลำดับการเดินด้วย `getMoves(id)`
4. แสดงตารางตาม `step` ที่เลือก (0..จำนวนตา) พร้อมปุ่มควบคุม  
   - ไปตาแรก, ย้อนทีละตา, เล่น/หยุดอัตโนมัติ, เดินต่อ, ไปตาสุดท้าย

---

## วิธีคิดของตรวจผู้ชนะ (`checkWinner`)

1. ลูปทุกแถว และทุกคอลัมน์  
2. ตรวจทีละทิศ (→, ↓, ↘, ↙)
   - 2.1 เช็คตัวสุดท้ายที่จะชนะของแต่ละแนวว่าหลุดนอกกระดานมั้ยถ้าไม่หลุดก็ไปต่อ
   - 2.2 ไล่เช็คตัวถัด ๆ ไปในทิศนั้น ถ้าเป็นค่าเดียวกันก็จนถึงจำนวนที่ต้องชนะก็รีเทินคนชนะไป  
   - 2.3 เช็คตัวต่อไปในแนวนั้นเรื่อยๆถ้าเป็นค่าเดียวกันก็จนถึงจำนวนที่ต้องชนะก็รีเทินคนชนะไป
3. ถ้าตรวจครบแล้วยังไม่เจอผู้ชนะ แต่ **กระดานเต็ม** → คืนค่า `"DRAW"`
4. ถ้ายังไม่เต็มและยังไม่เจอผู้ชนะ → คืนค่า `null` (เล่นต่อ)

---

## วิธีคิดของบอท AI (`getBestMove`)
รับค่าจากหน้าgame boardCells boardSize winCondition botSymbolฝั่งบอท  humanSymbolฝั่งคน
1. **หาวิธีชนะก่อน**  
   - เรียก`findImmediateWin(board, N, K, botSymbol)`ฝั่งบอท ไป
      - ทดลองวางบอทในทุกช่องว่าง แล้วเรียก `checkWinner`
      - ตรวจ `checkwinner` ถ้าบอทวางแล้วชนะ รีเทิร์น ตัวนั้น
2. **บล็อกคู่แข่งทันที**  
   - เรียก `findImmediateWin(board, N, K, humanSymbol)` ฝั่งคน ไป
      - ทดลองวางบอทในทุกช่องว่าง แล้วเรียก `checkWinner`
      - ตรวจ `checkwinner` ถ้าคนวางแล้วชนะ รีเทิร์น ตัวนั้นเพื่อให้บอทลงบล็อค
3. **กรณีบอร์ดเล็ก (≤ 4)**  
   - เลือก **กลาง** ถ้าว่างคืนค่าออก
   - ถ้ากลางไม่ว่าง → เลือก **มุม** แบบสุ่ม
4. **ไม่เข้าเงื่อนไขด้านบน** → ประเมินทุกช่องว่าง  
   - วนทุกช่องว่าง เรียก `evaluatePosition()` 2 ครั้ง:
   - ตรวจสอบถ้าตารางนั้นไม่ว่างมีตัวลงแล้วให้ข้าม
     - โหมดรุก: สมมติบอทลง (`symbol = botSymbol`) หาคะแนนว่าถ้าบอทลงตรงนี้คะแนนจากการประเมินมีทางออกเยอะมั้ย
     - โหมดรับ: สมมติคนลง (`symbol = humanSymbol`) หาคะแนนว่าถ้าบอทลงตรงนี้คะแนนจากการประเมินมีทางออกของคนเยอะมั้ย
   - รวมคะแนน: `total = attack + defense * 0.6` (เน้นรุก แต่ยังกันอยู่บ้าง)
   - เลือกช่องที่ `total` สูงสุด
5. **ไม่เจออะไรเลย** → สุ่มตำแหน่งว่าง

## วิธีคิดของ (`evaluatePosition`)
จำลองการวางลงก่อน
   - สร้างสำเนาบอร์ด `temp` แล้ววาง `symbol`("X"หรือ"O") ลงที่ `(row,col)`
   - ไล่ประเมินทั้ง 4 ทิศ
   - สำหรับแต่ละทิศ จะนับ ตัวเหมือนกัน โดยแบ่งเป็น 2 ด้านจากจุดวาง
      - ด้านหน้า`countLine(temp, N, row, col, dr, dc, symbol)`
      - ด้านหลัง`countLine(temp, N, row, col, -dr, -dc, symbol)`
      - รวมคะแนนตัวที่ติดกันและจำนวนฝั่งที่ว่างแต่ยังลงได้
      - ให้คะแนนตามหลัก
         - ชนะได้ทันที
         - ขาดแค่ 1 และมีช่องว่างให้ลง ≥ 1
         - ขาด 2 แต่ด้านข้างยังว่างอีก 2 ทาง 
         - อื่น ๆ ให้คะแนน ความต่อเนื่องกับจำนวนทางที่ยังลงได้
      - คำนวณตำแหน่งใกล้กลางยิ่งใกล้ยิ่งดี
      - รวมคะแนนทุกทิศคืนค่า คะแนนรวม

## วิธีคิดของการนับจำนวนทางที่ไปได้กี่ทางในแนวเดียว (`countLine`)
   - เดินไปทีละก้าวและถ้ายังอยู่ในกระดานและเป็น `symbol` เดิม ก็นับ `countSame++`
   - ถ้าปลายยังอยู่ในกระดาน และ เป็นช่องว่างนับเป็น `openEnd = 1`
