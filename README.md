# xo_game
## วิธีการออกแบบโปรแกรม

1) ออกแบบโมเดลฐานข้อมูล **MySQL**  
มี 2 ตารางหลัก

- **history_xo** (เก็บประวัติการเล่น)
  - `id` : รหัสของประวัติ  
  - `mode` : ประเภทของเกม เช่น `PVP`, `PVBOT`  
  - `sizeBoard` : ขนาดของตารางเกม  
  - `firstPlayer` : ผู้เล่นที่เริ่มก่อน  
  - `winner` : ผู้ชนะ  
  - `botType` : ประเภทของบอท เช่น `random`, `ai`  
  - `finalBoard` : ตารางสุดท้ายตอนจบเกม (บันทึกเป็นข้อความยาว เช่น `O,X,X,O,...`)

- **move** (เก็บการขยับแต่ละตา)
  - `id` : รหัสการขยับ  
  - `historyXO` : อ้างถึง `history_xo` (1 ประวัติ มีได้หลายการขยับ)  
  - `turnNumber` : ลำดับการลง  
  - `player` : ผู้ที่ลง (`"X"` หรือ `"O"`)  
  - `rowIdx` : แถวที่ลง  
  - `colIdx` : คอลัมน์ที่ลง  
  - `boardAfter` : สภาพกระดานหลังตานั้น

2) สร้างโปรเจ็กต์ **Spring Boot**  
**Dependencies** ที่เลือกใช้
- **Spring Web** : ใช้ HTTP/REST ติดต่อกันระหว่าง Frontend กับ Backend  
- **Spring Data JPA** : จัดการข้อมูลกับ DB ได้สะดวก ลดการเขียน SQL ยาว  
- **MySQL Driver** : ใช้ฐานข้อมูล MySQL  
- **Lombok** : ลด boilerplate code (Getter/Setter/Constructor)

3) สร้างโปรเจ็กต์ **React**
- ใช้ **React Router** จัดการเส้นทางของแต่ละหน้า (Home, Game, Replay)
- ใช้ **Axios** เรียก REST API เชื่อม Frontend ↔ Backend

---

## วิธีการทำงานหลัก (เล่นเกม)

1. หน้า **Home** เมื่อกรอกค่าต่าง ๆ แล้วกดปุ่ม **เริ่มเกม**  
2. ส่งค่าต่าง ๆ `firstPlayer` (สุ่ม), `mode`, `sizeBoard`, `K` (จำนวนเรียงเพื่อชนะ) ไปหน้า **Game**  
3. เมื่อเริ่มหน้า **Game** จะรับค่าจาก Home — ถ้าไม่มีค่า ส่งกลับไปหน้า Home  
4. หน้า Game จะเซ็ตค่าต่าง ๆ  
   - 4.1 นำ `sizeBoard` มาแปลงเป็นตารางว่าง  
   - 4.2 เซ็ตผู้เล่นคนแรกจาก `firstPlayer`  
5. ตั้งตัวแปรเตรียมข้อมูลสำหรับบันทึกลง **DB**  
6. ทุกอย่างเริ่มทำงานเมื่อมีการเดินครั้งแรก (กด `onCellClick` จากตาคนหรือบอท)
   - 6.1 ถ้า `player` คือ `"X"` (คน) → **อัปเดตตาราง**
   - 6.2 ถ้า `player` คือ `"O"` และ `botType = random`
       - 6.2.1 สุ่มช่องว่าง  
       - 6.2.2 **อัปเดตตาราง**
   - 6.3 ถ้า `player` คือ `"O"` และ `botType = ai`
       - 6.3.1 คำนวณ `getBestMove()` เลือกตำแหน่งที่ดีที่สุด  
       - 6.3.2 **อัปเดตตาราง**
   - 6.4 บันทึก DB (ครั้งแรกของเกม)
       - เรียก `ensureHistoryStarted()` → ภายในเรียก `startHistory()`  
         บันทึก `mode`, `sizeBoard`, `firstPlayer`, `botType` และ **รับ `id`** กลับมาเพื่อใช้บันทึกการขยับ
   - 6.5 แปลงตารางเป็นสตริงด้วย `cellsToString()` แล้วเรียก `appendMove()`  
       บันทึก `turnNumber`, `player`, `rowIdx`, `colIdx`, `boardAfter`
   - 6.6 ตรวจผู้ชนะด้วย `checkWinner()`  
       ถ้าชนะ → เรียก `finishHistory()` เพื่อบันทึก `winner`, `finalBoard`
7. กรณีรีเซ็ต/ออกกลางคัน
   - 7.1 ถ้าเกมเริ่มใน DB แล้ว แต่ยังไม่ `finish` ให้ลบด้วย `deleteHistory(id)`

---

## วิธีการทำงานจากหน้า Home → หน้า Replay

1. หน้า **Home** เมื่อกดปุ่ม **Replay** จะส่ง **`id`** ของประวัติไป  
2. หน้า **Replay** รับ `id` จาก URL  
3. เมื่อมาหน้า Replay แล้ว:
   - โหลดข้อมูลประวัติด้วย `getHistory(id)`
   - โหลดลำดับการเดินด้วย `getMoves(id)`
4. แสดงตารางตาม `step` ที่เลือก (0..จำนวนตา) พร้อมปุ่มควบคุม  
   - ไปตาแรก, ย้อนทีละตา, เล่น/หยุดอัตโนมัติ, เดินต่อ, ไปตาสุดท้าย

---

## วิธีคิดของตรวจผู้ชนะ (`checkWinner`)

1. ลูปทุกแถว และทุกคอลัมน์  
2. ตรวจทีละทิศ (→, ↓, ↘, ↙)
   - 2.1 เช็คตำแหน่งสุดท้ายของเส้นชนะ ว่าอยู่ในกระดานหรือไม่  
   - 2.2 ไล่เช็คตัวถัด ๆ ไปในทิศนั้น ถ้าไม่ตรงกันให้หยุด  
   - 2.3 ถ้าครบ `K` ตัวติดกัน → คืนค่าผู้ชนะ (`"X"` หรือ `"O"`)
3. ถ้าตรวจครบแล้วยังไม่เจอผู้ชนะ แต่ **กระดานเต็ม** → คืนค่า `"DRAW"`
4. ถ้ายังไม่เต็มและยังไม่เจอผู้ชนะ → คืนค่า `null` (เล่นต่อ)

---

## วิธีคิดของบอท AI (`getBestMove`)

1. **หาวิธีชนะทันที**  
   - เรียก `findImmediateWin(board, N, K, botSymbol)`  
   - ถ้าลงช่องใดแล้วชนะทันที → ลงตรงนั้นเลย
2. **บล็อกคู่แข่งทันที**  
   - เรียก `findImmediateWin(board, N, K, humanSymbol)`  
   - ถ้าคู่แข่งลงช่องใดแล้วจะชนะ → เราต้องลงช่องนั้นเพื่อบล็อก
3. **กรณีบอร์ดเล็ก (≤ 4)**  
   - เลือก **กลาง** ถ้าว่าง  
   - ถ้ากลางไม่ว่าง → เลือก **มุม** แบบสุ่ม
4. **ไม่เข้าเงื่อนไขด้านบน** → ประเมินทุกช่องว่าง  
   - วนทุกช่องว่าง เรียก `evaluatePosition()` 2 ครั้ง:
     - โหมดรุก: สมมติบอทลง (`symbol = botSymbol`)
     - โหมดรับ: สมมติคนลง (`symbol = humanSymbol`)
   - รวมคะแนน: `total = attack + defense * 0.6` (เน้นรุก แต่ยังกันอยู่บ้าง)
   - เลือกช่องที่ `total` สูงสุด
5. **ไม่เจออะไรเลย** → สุ่มตำแหน่งว่าง

---

## แผนภาพลำดับการทำงาน (Flow)
```mermaid
flowchart LR
  A[Home] -->|กดเริ่มเกม ส่ง mode/size/K/first| B[Game]
  B -->|เดินครั้งแรก| C[ensureHistoryStarted -> startHistory]
  B -->|ทุกครั้งที่เดิน| D[cellsToString -> appendMove]
  B -->|checkWinner| E{มีผู้ชนะหรือเสมอ?}
  E -- ใช่ --> F[finishHistory บันทึก winner/finalBoard]
  E -- ไม่ใช่ --> B
  A -->|กด Replay + ส่ง id| G[Replay]
  G --> H[getHistory(id)]
  G --> I[getMoves(id)]
  G --> J[ควบคุมแสดงตาย้อน/เล่นอัตโนมัติ]
