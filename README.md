# xo_game

[![ดูคลิปสาธิตโปรเจกต์](https://img.youtube.com/vi/m6LcDImQC7U/hqdefault.jpg)](https://youtu.be/m6LcDImQC7U)

## วิธีการออกแบบโปรแกรม
1) ออกแบบโมเดลฐานข้อมูล **MySQL**  
มี 2 ตารางหลัก

## ตาราง HistoryXO

| ชื่อคอลัมน์    | ชนิดข้อมูล     | เงื่อนไข         | คำอธิบาย             | ตัวอย่างข้อมูล |
|-----------------|----------------|------------------|----------------------|----------------|
| id              | BIGINT (AI, PK)| Primary Key      | รหัสประวัติการเล่น  | 1              |
| mode            | VARCHAR(10)    | NN               | ประเภทเกม (`PVP`, `PVBOT`) | PVP |
| sizeBoard       | INT            | NN               | ขนาดกระดาน          | 3              |
| firstPlayer     | VARCHAR(1)     | NN               | ผู้เล่นที่เริ่มก่อน  | X              |
| winner          | VARCHAR(10)    |                  | ผู้ชนะ (`X`, `O`, `DRAW`) | O |
| botType         | VARCHAR(10)    |         | ประเภทบอท            | RANDOM             |
| finalBoard      | TEXT           |              | สภาพกระดานสุดท้าย   | O,X,X,O,O,X... |

---

## ตาราง Move

| ชื่อคอลัมน์    | ชนิดข้อมูล     | เงื่อนไข         | คำอธิบาย             | ตัวอย่างข้อมูล |
|-----------------|----------------|------------------|----------------------|----------------|
| id              | BIGINT (AI, PK)| Primary Key      | รหัสการขยับ         | 1              |
| history_id      | BIGINT         | NN, FK           | อ้างถึง `HistoryXO.id` | 1 |
| turnNumber      | INT            | NN               | ลำดับการเล่น         | 5              |
| player          | VARCHAR(1)     | NN               | ผู้เล่นที่ลง         | X              |
| rowIdx          | INT            | NN               | แถวที่ลง             | 2              |
| colIdx          | INT            | NN               | คอลัมน์ที่ลง        | 1              |
| boardAfter      | TEXT           |                | กระดานตานี้   | O,X,,O,,...  |


2) สร้างโปรเจ็กต์ **Spring Boot**  
**Dependencies** ที่เลือกใช้
- **Spring Web** : ใช้ HTTP/REST ติดต่อกันระหว่าง Frontend กับ Backend  
- **Spring Data JPA** : จัดการข้อมูลกับ DB ได้สะดวก ลดการเขียน SQL ยาว  
- **MySQL Driver** : ใช้ฐานข้อมูล MySQL  
- **Lombok** : ลด code (Getter/Setter/Constructor)

3) สร้างโปรเจ็กต์ **React**
- ใช้ **React Router** จัดการเส้นทางของแต่ละหน้า (Home, Game, Replay)
- ใช้ **Axios** เรียก REST API เชื่อม Frontend ↔ Backend

---

## วิธีการทำงานหลัก (เล่นเกม)

1. หน้า **Home** เมื่อกรอกค่าต่าง ๆ แล้วกดปุ่ม **เริ่มเกม**  สามารถเลือกขนาดตารางได้ตั้งแต่ 3*3 ถึง 19*19
2. ส่งค่าต่าง ๆ `firstPlayer` (สุ่ม), `mode`, `sizeBoard`, `K` (จำนวนเรียงเพื่อชนะ) ไปหน้า **Game**  
3. เมื่อเริ่มหน้า **Game** จะรับค่าจาก Home — ถ้าไม่มีค่า ส่งกลับไปหน้า Home  
4. หน้า Game จะเซ็ตค่าต่าง ๆ  
   - 4.1 นำ `sizeBoard` มาแปลงเป็นตารางว่าง  
   - 4.2 เซ็ตผู้เล่นคนแรกจาก `firstPlayer`  
5. ตั้งตัวแปรเตรียมข้อมูลสำหรับบันทึกลง **DB**  
6. ทุกอย่างเริ่มทำงานเมื่อมีการเดินครั้งแรก (กด `onCellClick` จากตาคนหรือบอท)
   - 6.1 ถ้า `player` คือ `"X"` (คน) → **อัปเดตตาราง**
   - 6.2 ถ้า `player` คือ `"O"` และ `botType = random`
       - 6.2.1 สุ่มช่องว่าง  
       - 6.2.2 **อัปเดตตาราง**
   - 6.3 ถ้า `player` คือ `"O"` และ `botType = ai`
       - 6.3.1 คำนวณ `getBestMove()` เลือกตำแหน่งที่ดีที่สุด  
       - 6.3.2 **อัปเดตตาราง**
   - 6.4 บันทึก DB (ครั้งแรกของเกม)
       - เรียก `ensureHistoryStarted()` → ภายในเรียก `startHistory()`  
         บันทึก `mode`, `sizeBoard`, `firstPlayer`, `botType` และ **รับ `id`** กลับมาเพื่อใช้บันทึกการขยับ
   - 6.5 แปลงตารางเป็นสตริงด้วย `cellsToString()` แล้วเรียก `appendMove()`  
       บันทึก `turnNumber`, `player`, `rowIdx`, `colIdx`, `boardAfter`
   - 6.6 ตรวจผู้ชนะด้วย `checkWinner()`  
       ถ้าชนะ → เรียก `finishHistory()` เพื่อบันทึก `winner`, `finalBoard`
7. กรณีรีเซ็ต/ออกกลางคัน
   - 7.1 ถ้าเกมเริ่มใน DB แล้ว แต่ยังไม่ `finish` ให้ลบด้วย `deleteHistory(id)`

---

## วิธีการทำงานจากหน้า Home → หน้า Replay

1. หน้า **Home** เมื่อกดปุ่ม **Replay** จะส่ง **`id`** ของประวัติไป  
2. หน้า **Replay** รับ `id` จาก URL  
3. เมื่อมาหน้า Replay แล้ว:
   - โหลดข้อมูลประวัติด้วย `getHistory(id)`
   - โหลดลำดับการเดินด้วย `getMoves(id)`
4. แสดงตารางตาม `step` ที่เลือก (0..จำนวนตา) พร้อมปุ่มควบคุม  
   - ไปตาแรก, ย้อนทีละตา, เล่น/หยุดอัตโนมัติ, เดินต่อ, ไปตาสุดท้าย

---

## วิธีคิดของตรวจผู้ชนะ (`checkWinner`)

1. ลูปทุกแถว และทุกคอลัมน์  
2. ตรวจทีละทิศ (→, ↓, ↘, ↙)
   - 2.1 เช็คตัวสุดท้ายที่จะชนะของแต่ละแนวว่าหลุดนอกกระดานมั้ยถ้าไม่หลุดก็ไปต่อ
   - 2.2 ไล่เช็คตัวถัด ๆ ไปในทิศนั้น ถ้าเป็นค่าเดียวกันก็จนถึงจำนวนที่ต้องชนะก็รีเทินคนชนะไป  
   - 2.3 เช็คตัวต่อไปในแนวนั้นเรื่อยๆถ้าเป็นค่าเดียวกันก็จนถึงจำนวนที่ต้องชนะก็รีเทินคนชนะไป
3. ถ้าตรวจครบแล้วยังไม่เจอผู้ชนะ แต่ **กระดานเต็ม** → คืนค่า `"DRAW"`
4. ถ้ายังไม่เต็มและยังไม่เจอผู้ชนะ → คืนค่า `null` (เล่นต่อ)

---

## วิธีคิดของบอท AI (`getBestMove`)
รับค่าจากหน้าgame boardCells boardSize winCondition botSymbolฝั่งบอท  humanSymbolฝั่งคน
1. **หาวิธีชนะก่อน**  
   - เรียก`findImmediateWin(board, N, K, botSymbol)`ฝั่งบอท ไป
      - ทดลองวางบอทในทุกช่องว่าง แล้วเรียก `checkWinner`
      - ตรวจ `checkwinner` ถ้าบอทวางแล้วชนะ รีเทิร์น ตัวนั้น
2. **บล็อกคู่แข่งทันที**  
   - เรียก `findImmediateWin(board, N, K, humanSymbol)` ฝั่งคน ไป
      - ทดลองวางบอทในทุกช่องว่าง แล้วเรียก `checkWinner`
      - ตรวจ `checkwinner` ถ้าคนวางแล้วชนะ รีเทิร์น ตัวนั้นเพื่อให้บอทลงบล็อค
3. **กรณีบอร์ดเล็ก (≤ 4)**  
   - เลือก **กลาง** ถ้าว่างคืนค่าออก
   - ถ้ากลางไม่ว่าง → เลือก **มุม** แบบสุ่ม
4. **ไม่เข้าเงื่อนไขด้านบน** → ประเมินทุกช่องว่าง  
   - วนทุกช่องในตาราง เช่น ตาราง 3*3 จะมี [X,?,,O,,,X,]
## กระดาน XO (เปรียบเทียบ) 
**Index Board**
| 0 | 1 | 2 |
|---|---|---|
| 3 | 4 | 5 |
| 6 | 7 | 8 |

**Current Board**
| X | ? |   |
|---|---|---|
|   | O |   |
|   | X |   |
   - ตรวจสอบถ้าช่องนั้นไม่ว่างมีตัวลงแล้วให้ข้าม
   - เรียก `evaluatePosition()` 2 ครั้ง:
     - โหมดรุก: สมมติบอทลง (`symbol = botSymbol`) - โหมดรุก: สมมติบอทลง  
  [ (boardCells, boardSize, winCondition, row, col, botSymbol) ](#วิธีคิดของ-evaluateposition)  
  หาคะแนนว่าถ้าบอทลงตรงนี้มีทางออกเยอะมั้ย
 หาคะแนนว่าถ้าบอทลงตรงนี้คะแนนจากการประเมินมีทางออกเยอะมั้ย
     - โหมดรับ: สมมติคนลง (`symbol = humanSymbol`) หาคะแนนว่าถ้าบอทลงตรงนี้คะแนนจากการประเมินมีทางออกของคนเยอะมั้ย
   - รวมคะแนน: `total = attack + defense * 0.6` (เน้นรุก แต่ยังกันอยู่บ้าง)
   - เลือกช่องที่ `total` สูงสุด
5. **ไม่เจออะไรเลย** → สุ่มตำแหน่งว่าง

## วิธีคิดของ (`evaluatePosition`)
จำลองการวางลงก่อนรับค่า (boardCells, boardSize, winCondition, row, col, symbol)
   - สร้างสำเนาบอร์ด `temp` แล้ววาง `symbol`("X"หรือ"O") ลงที่ `(row,col)` เช่นรับค่า `(0,1)`
     
**ลองลงOที่ช่อง(0,1)**
| X | O |   |
|---|---|---|
|   | O |   |
|   | X |   |

   จะลง O ที่ [X,O(ตรงนี้),,O,,,X,]
   - ไล่ประเมินทั้ง 4 ทิศ เช่นอันแรกทางแนวนอน
   - สำหรับแต่ละทิศ จะนับ ตัวเหมือนกัน และช่องที่ยังว่าง โดยแบ่งเป็น 2 ด้านจากจุดวาง
      - ด้านหน้าคือฝั่งขวา`countLine(temp, N, row, col, dr, dc, symbol)` โดยจำนค่า `row+dr = 0+0 = 0`  แล้วก็ `col+dc = 1+1 =2`
   
**จะได้ตำแหน่ง(0,2)**
| X | O | ? |
|---|---|---|
|   | O |   |
|   | X |   |
   - ตรวจสอบทีละช่องถ้ายังอยู่ในกระดานและเป็น `symbol` เดิม ก็นับ `countSame++` ตอนนี้ช่อง (0,2) ไม่มี `symbol` ที่เหมือนกัน `countSame = 0`
   - และค่า `openEnd = 1` เพราะเป็นช่องว่าง
      - ด้านหลัง`countLine(temp, N, row, col, -dr, -dc, symbol)` จะเช็คฝั่งตรงข้ามคือฝั่งซ้ายจะได้ `countSame = 0` `openEnd = 0` เพราะช่องนั้นมีตัว X ลงไว้อยู่ 
      - รวมคะแนนตัวที่ติดกันและจำนวนฝั่งที่ว่างแต่ยังลงได้
      - ให้คะแนนตามหลัก
         - ชนะได้ทันที
         - ขาดแค่ 1 และมีช่องว่างให้ลง ≥ 1
         - ขาด 2 แต่ด้านข้างยังว่างอีก 2 ทาง 
         - อื่น ๆ ให้คะแนน ความต่อเนื่องกับจำนวนทางที่ยังลงได้
      - คำนวณตำแหน่งใกล้กลางยิ่งใกล้ยิ่งดี
      - รวมคะแนนทุกทิศคืนค่า คะแนนรวม และเลือก คะแนนของช่องที่ดีที่สุด

## วิธีคิดของการนับจำนวนทางที่ไปได้กี่ทางในแนวเดียว (`countLine`)
   - เดินไปทีละก้าวและถ้ายังอยู่ในกระดานและเป็น `symbol` เดิม ก็นับ `countSame++`
   - ถ้าปลายยังอยู่ในกระดาน และ เป็นช่องว่างนับเป็น `openEnd = 1`
