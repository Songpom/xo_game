# xo_game

## วิธีการออกแบบโปรแกรม

1) ออกแบบโมเดลฐานข้อมูล **MySQL**  
มี 2 ตารางหลัก

- **history_xo** เก็บประวัติการเล่น
  - `id` : รหัสของประวัติ  
  - `mode` : ประเภทของเกม เช่น `PVP`, `PVBOT`  
  - `sizeBoard` : ขนาดของตารางเกม  
  - `firstPlayer` : ผู้เล่นที่เริ่มก่อน  
  - `winner` : ผู้ชนะ  
  - `botType` : ประเภทของบอท เช่น `random`, `ai`  
  - `finalBoard` : ตารางสุดท้ายตอนจบเกมข้อความยาว เช่น `O,X,X,O,...`

- **move** เก็บการขยับแต่ละตา
  - `id` : รหัสการขยับ  
  - `historyXO` : เก็บรหัสของประวัติ 1 ประวัติ มีได้หลายการขยับ 
  - `turnNumber` : ลำดับการลง  
  - `player` : ผู้ที่ลง (`"X"` หรือ `"O"`)  
  - `rowIdx` : แถวที่ลง  
  - `colIdx` : คอลัมน์ที่ลง  
  - `boardAfter` : สภาพกระดานตานั้น

2) สร้างโปรเจ็กต์ **Spring Boot**  
**Dependencies** ที่เลือกใช้
- **Spring Web** : ใช้ HTTP,REST ติดต่อกันระหว่าง Frontend กับ Backend  
- **Spring Data JPA** : จัดการข้อมูลกับ DB ได้สะดวก ไม่ต้องเขียนคำสั่ง SQL ยาว  
- **MySQL Driver** : ใช้ฐานข้อมูล MySQL  
- **Lombok** : ลดการเขียนพวก Get Set Constructor

3) สร้างโปรเจ็กต์ **React**
- ใช้ **React Router** จัดการเส้นทางของแต่ละหน้า Home, Game, Replay
- ใช้ **Axios** ในการเชื่อมระหว่าง frontend ผ่าน rest api กับ backend

---

## วิธีการทำงานหลัก (เล่นเกม)

1. หน้า **Home** เมื่อกรอกค่าต่าง ๆ แล้วกดปุ่ม **เริ่มเกม**  
2. ส่งค่าต่าง ๆ `firstPlayer` (สุ่ม), `mode`, `sizeBoard`, `K` (จำนวนเรียงเพื่อชนะ) ไปหน้า **Game**  
3. เมื่อเริ่มหน้า **Game** จะรับค่าจาก Home — ถ้าไม่มีค่า ส่งกลับไปหน้า Home  
4. หน้า Game จะเซ็ตค่าต่าง ๆ  
   - 4.1 นำ `sizeBoard` มาแปลงเป็นตารางว่าง  
   - 4.2 เซ็ตผู้เล่นคนแรกจาก `firstPlayer`  
5. ตั้งตัวแปรเตรียมข้อมูลสำหรับบันทึกลง **DB**  
6. ทุกอย่างเริ่มทำงานเมื่อมีการเดินครั้งแรก กด `onCellClick` จากตาคนหรือบอท
   - 6.1 ถ้า `player` คือ `"X"` (คน) → **อัปเดตตาราง**
   - 6.2 ถ้า `player` คือ `"O"` และ `botType ` คือ` random`
       - 6.2.1 สุ่มช่องว่าง  
       - 6.2.2 **อัปเดตตาราง**
   - 6.3 ถ้า `player` คือ `"O"` และ `botType` คือ` ai`
       - 6.3.1 คำนวณ `getBestMove()` เลือกตำแหน่งที่ดีที่สุด  
       - 6.3.2 **อัปเดตตาราง**
   - 6.4 บันทึก DB (ครั้งแรกของเกม)
       - เรียก `ensureHistoryStarted()` → ภายในเรียก `startHistory()`  
         บันทึก `mode`, `sizeBoard`, `firstPlayer`, `botType` และ **รับ `id`** กลับมาเพื่อใช้บันทึกการขยับ
   - 6.5 แปลงตารางเป็นสตริงด้วย `cellsToString()` แล้วเรียก `appendMove()`  
       บันทึก `turnNumber`, `player`, `rowIdx`, `colIdx`, `boardAfter`
   - 6.6 ตรวจผู้ชนะด้วย `checkWinner()`  
       ถ้าชนะเรียก `finishHistory()` เพื่อบันทึก `winner`, `finalBoard`
7. กรณีรีเซ็ต/ออกกลางคัน
   - 7.1 ถ้าเกมเริ่มใน DB แล้ว แต่ยังไม่ `finish` ให้ลบด้วย `deleteHistory(id)`

---

## วิธีการทำงานจากหน้า Home → หน้า Replay

1. หน้า **Home** เมื่อกดปุ่ม **Replay** จะส่ง **`id`** ของประวัติไป  
2. หน้า **Replay** รับ `id` จาก URL  
3. เมื่อมาหน้า Replay แล้ว:
   - โหลดข้อมูลประวัติด้วย `getHistory(id)`
   - โหลดลำดับการเดินด้วย `getMoves(id)`
4. แสดงตารางตาม `step` ที่เลือก (0..จำนวนตา) พร้อมปุ่มควบคุม  
   - ไปตาแรก, ย้อนทีละตา, เล่น/หยุดอัตโนมัติ, เดินต่อ, ไปตาสุดท้าย

---

## วิธีคิดของตรวจผู้ชนะ `checkWinner`

1. ลูปทุกแถว และทุกคอลัมน์  
2. ตรวจทีละทิศ 
   - 2.1 เช็คตำแหน่งสุดท้ายของทางชนะ ว่าอยู่ในกระดานหรือไม่  
   - 2.2 ไล่เช็คตัวถัด ๆ ไปในทิศนั้น ถ้าไม่ตรงกันให้หยุด  
   - 2.3 ถ้าครบ `K` ตัวติดกัน → คืนค่าผู้ชนะ (`"X"` หรือ `"O"`)
3. ถ้าตรวจครบแล้วยังไม่เจอผู้ชนะ แต่ **กระดานเต็ม** → คืนค่า `"DRAW"`
4. ถ้ายังไม่เต็มและยังไม่เจอผู้ชนะ → คืนค่า `null` (เล่นต่อ)

---

## วิธีคิดของบอท AI (`getBestMove`)
1.  รับค่าจากหน้า game เรียก `getBestMove` ส่ง `boardCells boardSize winCondition botSymbolฝั่งบอท  humanSymbolฝั่งคน`
2. **หาวิธีชนะ**  
   - เรียก `findImmediateWin(board, N, K, botSymbol)`
       - ทดลองวางบอทในทุกช่องว่าง แล้วเรียก checkWinner
		   - ตรวจcheckwinnerถ้าวางแล้วชนะ รีเทิร์น ตัวนั้น นั้น
3. **บล็อกคู่แข่ง**  
   - เรียก `findImmediateWin(board, N, K, humanSymbol)`  
       - ทดลองวางบอทในทุกช่องว่าง แล้วเรียก checkWinner
		   - ตรวจcheckwinnerถ้าวางแล้วชนะ รีเทิร์น ตัวนั้น นั้น
4. **กรณีบอร์ดเล็ก**  
   - เลือก **กลาง** ถ้าว่าง  
   - ถ้ากลางไม่ว่าง → เลือก **มุม** แบบสุ่ม
5. **ไม่เข้าเงื่อนไขด้านบน** ประเมินทุกช่องว่าง  
   - วนทุกช่องว่าง เรียก `evaluatePosition()` 2 ครั้ง:
     - รุกสมมติบอทลง (`symbol = botSymbol`)
     - รับสมมติคนลง (`symbol = humanSymbol`)
   - รวมคะแนน: `total = attack + defense * 0.6` เน้นรุก
   - เลือกช่องที่ `total` สูงสุด
6. **ไม่เจออะไรเลย** → สุ่มตำแหน่งว่าง

