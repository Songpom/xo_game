# xo_gmae
วิธีการออกแบบโปรแกรม
1.ออกแบบโมเดลฐานข้อมูล MySQL
	โดยจะมี2ตาราง
	1.history_xoโดยจะเก็บ
		-id รหัสของประวัติ
		-mode ประเภทของเกม เช่น PVP PVBOT
		-sizeBoard ขนาดของตารางเกม
		-firstPlayer ผู้เล่นที่เริ่มก่อน
		-winner ผู้เล่นที่ชนะ
		-botType ประเภทของบอทจะมี random กับ ai
		-finalBoard ตารางสุดท้ายตอนจบเกมแล้ว จะเก็บเป็นข้อมูลอเป็นข้อความยาว O,X,X,O,...
	2.moveโดยจะเก็บ
		-id รหัสการขยับ
		-historyXO เก็บรหัสของประวัติ 1ประวัติมีได้หลายการขยับ
		-turnNumber ลำดับการลง
		-player ผู้ที่ลง
		-rowIdx แถวที่ลง
		-colIdx คอลัมที่ลง
		-boardAfter ตารางการแข่งขันของแต่ละเทิน
2.สร้างโปรเจคจากSpring Boot
	dependencyที่เลือกใช้
		-Spring WEB เพราะใช้ HTTP ติดต่อกันระหว่างหน้าบ้านกับหลังบ้าน
		-Spring data JPA เรียกข้อมูลจากฐานข้อมูลง่ายไม่ต้องเขียน SQL ยาว
		-MySQL Driver เพราะโปรเจคนี้ใช้ MySQL เป็นฐานข้อมูล
		-Lombok ลดการเขียนพวก Get Set Constructor
3.สร้างโปรเจคReact
	ใช้React Router เรียกแท็กของแต่ละหน้า
    ใช้axios ในการเชื่อมระหว่าง frontend ผ่าน rest api กับ backend






วิธีการทำงานหลักเล่นเกม
1.หน้า home เมื่อกรอกค่าต่างๆ แล้วกดปุ่มเริ่มเกม
2.ส่งค่าต่างๆ firstplayer(สุ่ม), mode, sizeboard, K(จำนวนเรียงเพื่อชนะ) ไปหน้า Game
3.พอเริ่มหน้าgame จะรับค่าจากหน้า home มาถ้าไม่มีจะกลับไปหน้า home 
4.หน้าgameจะเซ็ตค่าต่างๆ
	4.1เอาค่า sizeboardมาแปลงเป็นตาราง
	4.2เอาค่าผู้เล่นคนแรกมาเซ็ต
5.ตั้งตัวแปรเตรียมข้อมูลสำหรับจะบันทึกลงDB
6.ทุกอย่างจะเริ่มทำงานเมื่อถูกเรียกครั้งแรกที่มีการเดินตา เมื่อกดonCellClick จากตาคนหรือบอท
	6.1ถ้า  playerคือ x คือคน
		6.1.1อัพเดตตาราง
	6.2ถ้า  playerคือ o แล้ว bottypeคือ random
		6.2.1สุ่มลง
		6.2.2อัพเดตตาราง
	6.3ถ้า  playerคือ o แล้ว bottypeคือ ai
		6.3.1คำนวณ getBestMove เลือกตำแหน่งที่ดีที่สุดลง
		6.3.2อัพเดตตาราง
	6.4ส่งไปบันทึกเรียก ensureHistoryStarted เรียก startHistory() เพื่อบันทึกmode sizeBoard, firstPlayer, botType, ลงDBแล้วส่งค่าidกลับมาเอาไว้ใช้บันทึกการขยับ
	6.5แปลงค่าเซลเป็นสตริง cellsToString แล้วเรียก appendMove เพื่อบันทึก appendMove(), player, rowIdx, colIdx boardAfter, ลงDB
	6.6ตรวจว่าชนะมั้ยจาก checkWinner ถ้าชนะส่งข้อมูลไปบันทึกเรียก finishHistory() เพื่อบันทึก winner, finalBoard, ลงDB
7.กรณีรีเซ็ต/ออกกลางคัน
	7.1ถ้าเกมเริ่มใน DB แล้ว แต่ยังไม่ finish ลบด้วย deleteHistory ส่ง id ไป 


วิธีการทำงานหน้าหลักไปหน้าประวัติการขยับ
1.หน้า home เมื่อกดปุ่ม Replay ส่ง id ของประวัติไป
2.รับค่าจากหน้า home คือ id 
3.เมื่อมาหน้าreplayแล้วรับค่าidแล้วทำการค้นข้อมูลประวัติกับการขยับจาก getHistory() กับ getMoves()



วิธีคิดของตรวจชนะ
checkwinner
	1.สร้างลูปแถว แล้วแถวคอลัมข้างใน
	2.เช็คทีละแนว
		2.1เช็คตัวสุดท้ายที่จะชนะของแต่ละแนวว่าหลุดนอกกระดานมั้ยถ้าไม่หลุดก็ไปต่อ
		2.2เช็คตัวต่อไปในแนวนั้นถ้าเป็นค่าเดียวกันก็จนถึงจำนวนที่ต้องชนะก็รีเทินคนชนะไป
	3.ถ้าตรวจแล้วทั้งตารางแต่เต็มตารางแล้วแต่ยังไม่รู้ผลรีเทินเสมอ
	4.ถ้ายังไม่เต็มยังไม่เจอคนชนะรีเทินว่างเล่นต่อ

วิธีคิดของบอท ai จากข้อ 6.3.1 
getbestmove
	1.รับค่าจากหน้าgame boardCells boardSize winCondition botSymbolฝั่งบอท  humanSymbolฝั่งคน
	2.หาวิธีชนะก่อน เรียกfindImmediateWin ส่ง boardCells, boardSize, winCondition, botSymbolฝั่งบอท ไป 
		2.1ทดลองวางบอทในทุกช่องว่าง แล้วเรียก checkWinner
		2.2ตรวจcheckwinnerถ้าวางแล้วชนะ รีเทิร์น ตัวนั้น นั้น
	3.ถ้าไม่เจอวิธีชนะเรียกfindImmediateWin ส่ง boardCells, boardSize, winCondition, humanSymbolฝั่งคน ไป
		3.1ตรวจcheckwinnerถ้าคนลงช่องไหนแล้วจะชนะ เราลงช่องนั้นเพื่อบล็อก
	4.กรณีตารางเล็กน้อยกว่าหรือเท่ากับ4
		4.1หาจุดกลางก่อนถ้าจุดกลางว่างคืนค่าออก
		4.2ถ้ากลางไม่ว่างหามุมแล้วสุ่มเลือก
	5กรณีผ่าน 3 เงื่อนไขนี้ไปทั้งหมด
		5.1 วนลูปช่องตารางทั้งหมด
			5.1.1ถ้าตารางไม่ว่างข้าม
			5.1.2ถ้าตารางว่างเข้ามาหาวิธี
				5.1.2.1หาคะแนนว่าถ้าบอทลงตรงนี้ จะช่วยให้เราใกล้ชนะมั้ย เช่น วางแล้วได้ 3 ตัวติด
				5.1.2.2คะแนนว่าถ้าคนได้ช่องนี้ มันจะอันตรายแค่ไหน เช่น คนวางช่องนี้ได้ 3 ตัวติด
				5.1.2.3รวมคะแนนละถ่วงเกมรับไว้แค่60เปอเซ็นพอเกมรับไป100ให้รุกมากกว่า
				5.1.2.4เลือกคะแนนที่ดีที่สุดคืนค่าไป
	6.ถ้าไม่มีคะแนนที่ดีที่สุดบอทสุ่มเลือก




		
  
	
